// Code generated by go-swagger; DO NOT EDIT.

package time_series

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new time series API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for time series API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
GetActivitiesResourceByDateIntraday gets intraday time series

Returns the Intraday Time Series for a given resource in the format requested.
*/
func (a *Client) GetActivitiesResourceByDateIntraday(params *GetActivitiesResourceByDateIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesResourceByDateIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesResourceByDateIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesResourceByDateIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/{resource-path}/date/{date}/1d/{detail-level}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesResourceByDateIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesResourceByDateIntradayOK), nil

}

/*
GetActivitiesResourceByDatePeriod gets activity time series

Returns time series data in the specified range for a given resource in the format requested using units in the unit system that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetActivitiesResourceByDatePeriod(params *GetActivitiesResourceByDatePeriodParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesResourceByDatePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesResourceByDatePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesResourceByDatePeriod",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/{resource-path}/date/{date}/{period}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesResourceByDatePeriodReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesResourceByDatePeriodOK), nil

}

/*
GetActivitiesResourceByDateRange gets activity time series

Returns time series data in the specified range for a given resource.
*/
func (a *Client) GetActivitiesResourceByDateRange(params *GetActivitiesResourceByDateRangeParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesResourceByDateRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesResourceByDateRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesResourceByDateRange",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/{resource-path}/date/{base-date}/{end-date}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesResourceByDateRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesResourceByDateRangeOK), nil

}

/*
GetActivitiesResourceByDateRangeIntraday gets intraday time series

Returns the Intraday Time Series for a given resource in the format requested.
*/
func (a *Client) GetActivitiesResourceByDateRangeIntraday(params *GetActivitiesResourceByDateRangeIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesResourceByDateRangeIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesResourceByDateRangeIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesResourceByDateRangeIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/{resource-path}/date/{base-date}/{end-date}/{detail-level}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesResourceByDateRangeIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesResourceByDateRangeIntradayOK), nil

}

/*
GetActivitiesResourceByDateRangeTimeSeriesIntraday gets intraday time series

Returns the Intraday Time Series for a given resource in the format requested.
*/
func (a *Client) GetActivitiesResourceByDateRangeTimeSeriesIntraday(params *GetActivitiesResourceByDateRangeTimeSeriesIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesResourceByDateRangeTimeSeriesIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesResourceByDateRangeTimeSeriesIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesResourceByDateRangeTimeSeriesIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/{resource-path}/date/{date}/{end-date}/{detail-level}/time/{start-time}/{end-time}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesResourceByDateRangeTimeSeriesIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesResourceByDateRangeTimeSeriesIntradayOK), nil

}

/*
GetActivitiesResourceByDateTimeSeriesIntraday gets intraday time series

Returns the Intraday Time Series for a given resource in the format requested.
*/
func (a *Client) GetActivitiesResourceByDateTimeSeriesIntraday(params *GetActivitiesResourceByDateTimeSeriesIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesResourceByDateTimeSeriesIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesResourceByDateTimeSeriesIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesResourceByDateTimeSeriesIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/{resource-path}/date/{date}/1d/{detail-level}/time/{start-time}/{end-time}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesResourceByDateTimeSeriesIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesResourceByDateTimeSeriesIntradayOK), nil

}

/*
GetActivitiesTrackerResourceByDatePeriod gets activity time series

Returns time series data in the specified range for a given resource in the format requested using units in the unit system that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetActivitiesTrackerResourceByDatePeriod(params *GetActivitiesTrackerResourceByDatePeriodParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesTrackerResourceByDatePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesTrackerResourceByDatePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesTrackerResourceByDatePeriod",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/tracker/{resource-path}/date/{date}/{period}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesTrackerResourceByDatePeriodReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesTrackerResourceByDatePeriodOK), nil

}

/*
GetActivitiesTrackerResourceByDateRange gets activity time series

Returns time series data in the specified range for a given resource.
*/
func (a *Client) GetActivitiesTrackerResourceByDateRange(params *GetActivitiesTrackerResourceByDateRangeParams, authInfo runtime.ClientAuthInfoWriter) (*GetActivitiesTrackerResourceByDateRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActivitiesTrackerResourceByDateRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getActivitiesTrackerResourceByDateRange",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/tracker/{resource-path}/date/{base-date}/{end-date}.json",
		ProducesMediaTypes: []string{"application/x-www-form-urlencoded"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActivitiesTrackerResourceByDateRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActivitiesTrackerResourceByDateRangeOK), nil

}

/*
GetBodyResourceByDatePeriod gets body time series

Returns time series data in the specified range for a given resource in the format requested using units in the unit system that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetBodyResourceByDatePeriod(params *GetBodyResourceByDatePeriodParams, authInfo runtime.ClientAuthInfoWriter) (*GetBodyResourceByDatePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBodyResourceByDatePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBodyResourceByDatePeriod",
		Method:             "GET",
		PathPattern:        "/1/user/-/body/{resource-path}/date/{date}/{period}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBodyResourceByDatePeriodReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBodyResourceByDatePeriodOK), nil

}

/*
GetBodyResourceByDateRange gets body time series

Returns time series data in the specified range for a given resource in the format requested using units in the unit system that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetBodyResourceByDateRange(params *GetBodyResourceByDateRangeParams, authInfo runtime.ClientAuthInfoWriter) (*GetBodyResourceByDateRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBodyResourceByDateRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBodyResourceByDateRange",
		Method:             "GET",
		PathPattern:        "/1/user/-/body/{resource-path}/date/{base-date}/{end-date}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetBodyResourceByDateRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBodyResourceByDateRangeOK), nil

}

/*
GetFoodsByDateRange gets food or water time series

Updates a user's daily activity goals and returns a response using units in the unit system which corresponds to the Accept-Language header provided.
*/
func (a *Client) GetFoodsByDateRange(params *GetFoodsByDateRangeParams, authInfo runtime.ClientAuthInfoWriter) (*GetFoodsByDateRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFoodsByDateRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFoodsByDateRange",
		Method:             "GET",
		PathPattern:        "/1/user/-/foods/log/{resource-path}/date/{base-date}/{end-date}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFoodsByDateRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFoodsByDateRangeOK), nil

}

/*
GetFoodsResourceByDatePeriod gets food or water time series

Updates a user's daily activity goals and returns a response using units in the unit system which corresponds to the Accept-Language header provided.
*/
func (a *Client) GetFoodsResourceByDatePeriod(params *GetFoodsResourceByDatePeriodParams, authInfo runtime.ClientAuthInfoWriter) (*GetFoodsResourceByDatePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFoodsResourceByDatePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFoodsResourceByDatePeriod",
		Method:             "GET",
		PathPattern:        "/1/user/-/foods/log/{resource-path}/date/{date}/{period}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFoodsResourceByDatePeriodReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFoodsResourceByDatePeriodOK), nil

}

/*
GetHeartByDateIntraday gets heart rate intraday time series

Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
*/
func (a *Client) GetHeartByDateIntraday(params *GetHeartByDateIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetHeartByDateIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHeartByDateIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHeartByDateIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/heart/date/{date}/1d/{detail-level}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHeartByDateIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHeartByDateIntradayOK), nil

}

/*
GetHeartByDatePeriod gets heart rate time series

Returns the time series data in the specified range for a given resource in the format requested using units in the unit systems that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetHeartByDatePeriod(params *GetHeartByDatePeriodParams, authInfo runtime.ClientAuthInfoWriter) (*GetHeartByDatePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHeartByDatePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHeartByDatePeriod",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/heart/date/{date}/{period}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHeartByDatePeriodReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHeartByDatePeriodOK), nil

}

/*
GetHeartByDateRange gets heart rate time series

Returns the time series data in the specified range for a given resource in the format requested using units in the unit systems that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetHeartByDateRange(params *GetHeartByDateRangeParams, authInfo runtime.ClientAuthInfoWriter) (*GetHeartByDateRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHeartByDateRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHeartByDateRange",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/heart/date/{base-date}/{end-date}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHeartByDateRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHeartByDateRangeOK), nil

}

/*
GetHeartByDateRangeIntraday gets heart rate intraday time series

Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
*/
func (a *Client) GetHeartByDateRangeIntraday(params *GetHeartByDateRangeIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetHeartByDateRangeIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHeartByDateRangeIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHeartByDateRangeIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/heart/date/{date}/{end-date}/{detail-level}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHeartByDateRangeIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHeartByDateRangeIntradayOK), nil

}

/*
GetHeartByDateRangeTimestampIntraday gets heart rate intraday time series

Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
*/
func (a *Client) GetHeartByDateRangeTimestampIntraday(params *GetHeartByDateRangeTimestampIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetHeartByDateRangeTimestampIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHeartByDateRangeTimestampIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHeartByDateRangeTimestampIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/heart/date/{date}/{end-date}/{detail-level}/time/{start-time}/{end-time}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHeartByDateRangeTimestampIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHeartByDateRangeTimestampIntradayOK), nil

}

/*
GetHeartByDateTimestampIntraday gets heart rate intraday time series

Returns the intraday time series for a given resource in the format requested. If your application has the appropriate access, your calls to a time series endpoint for a specific day (by using start and end dates on the same day or a period of 1d), the response will include extended intraday values with a one-minute detail level for that day. Unlike other time series calls that allow fetching data of other users, intraday data is available only for and to the authorized user.
*/
func (a *Client) GetHeartByDateTimestampIntraday(params *GetHeartByDateTimestampIntradayParams, authInfo runtime.ClientAuthInfoWriter) (*GetHeartByDateTimestampIntradayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHeartByDateTimestampIntradayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHeartByDateTimestampIntraday",
		Method:             "GET",
		PathPattern:        "/1/user/-/activities/heart/date/{date}/1d/{detail-level}/time/{start-time}/{end-time}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetHeartByDateTimestampIntradayReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHeartByDateTimestampIntradayOK), nil

}

/*
GetSleepResourceByDatePeriod gets sleep time series

Returns time series data in the specified range for a given resource in the format requested using units in the unit system that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetSleepResourceByDatePeriod(params *GetSleepResourceByDatePeriodParams, authInfo runtime.ClientAuthInfoWriter) (*GetSleepResourceByDatePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSleepResourceByDatePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSleepResourceByDatePeriod",
		Method:             "GET",
		PathPattern:        "/1/user/-/sleep/{resource-path}/date/{date}/{period}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSleepResourceByDatePeriodReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSleepResourceByDatePeriodOK), nil

}

/*
GetSleepResourceByDateRange gets sleep time series

Returns time series data in the specified range for a given resource in the format requested using units in the unit system that corresponds to the Accept-Language header provided.
*/
func (a *Client) GetSleepResourceByDateRange(params *GetSleepResourceByDateRangeParams, authInfo runtime.ClientAuthInfoWriter) (*GetSleepResourceByDateRangeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSleepResourceByDateRangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSleepResourceByDateRange",
		Method:             "GET",
		PathPattern:        "/1/user/-/sleep/{resource-path}/date/{base-date}/{end-date}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSleepResourceByDateRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSleepResourceByDateRangeOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
