// Code generated by go-swagger; DO NOT EDIT.

package subscriptions

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new subscriptions API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for subscriptions API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddSubscriptions adds a subscription

Adds a subscription in your application so that users can get notifications and return a response in the format requested. The subscription-id value provides a way to associate an update with a particular user stream in your application.
*/
func (a *Client) AddSubscriptions(params *AddSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter) (*AddSubscriptionsOK, *AddSubscriptionsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddSubscriptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addSubscriptions",
		Method:             "POST",
		PathPattern:        "/1/user/-/{collection-path}/apiSubscriptions/{subscription-id}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddSubscriptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *AddSubscriptionsOK:
		return value, nil, nil
	case *AddSubscriptionsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteSubscriptions deletes a subscription

Deletes a subscription for a user..
*/
func (a *Client) DeleteSubscriptions(params *DeleteSubscriptionsParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSubscriptionsCreated, *DeleteSubscriptionsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSubscriptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteSubscriptions",
		Method:             "DELETE",
		PathPattern:        "/1/user/-/{collection-path}/apiSubscriptions/{subscription-id}.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteSubscriptionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteSubscriptionsCreated:
		return value, nil, nil
	case *DeleteSubscriptionsNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetSubscriptionsList gets a list of subscriptions

Retreives a list of a user's subscriptions for your application in the format requested. You can either fetch subscriptions for a specific collection or the entire list of subscriptions for the user. For best practice, make sure that your application maintains this list on your side and use this endpoint only to periodically ensure data consistency.
*/
func (a *Client) GetSubscriptionsList(params *GetSubscriptionsListParams, authInfo runtime.ClientAuthInfoWriter) (*GetSubscriptionsListOK, *GetSubscriptionsListCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSubscriptionsListParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getSubscriptionsList",
		Method:             "GET",
		PathPattern:        "/1/user/-/{collection-path}/apiSubscriptions.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSubscriptionsListReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetSubscriptionsListOK:
		return value, nil, nil
	case *GetSubscriptionsListCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
